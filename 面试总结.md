##### GET和POST的区别
1.

#####浏览器的一个请求从发送到返回都经历了什么？
1.用户在浏览器输入一个url,浏览器内部将url进行拆分解析，将domain发送到dns服务器上，dns会查询相关host对于的IP地址， 从而将IP地址返回给浏览器，浏览器在持有IP地址之后，IP地址跟随协议并且请求相关的参数都会在协议中携带，最终发送到网络中去，经过局域网，交换机，路由器，主干网络，到达服务端，服务端有一个MVC架构，请求会首先在Controller中进行数据逻辑处理以及请求的分发，然后调用Model层，Model层是和数据进行交互的过程中，Model层会去读取Redis+mysql里面的数据，获取到数据后，最终将我们渲染好的页面返回给我们的网络，最终response响应回到浏览器，浏览器主要做一个render的过程，在渲染的过程中，浏览器根据html会形成相关的dom树以及css树，将dom树和css树进行一个整合，从而在页面上进行样式的渲染，样式渲染完成之后，浏览器会进一步执行下面的js脚本，从而页面展现出来。

##### web性能优化
^在这个过程中，有哪些点可以进行前端的性能优化
--减少请求的时间: 
1.减少访问dns的时间，浏览器层面和路由器层面进行dns相关信息缓存
2.减少网络请求的过程，带宽，网络的选择，缓存，cdn（请求静态资源）
cdn的域名不要和主站的一样，减少主站请求带cookie一个损耗的过程
3.浏览器端的缓存策略
4.减少http请求的大小

请求过程中一些潜在的性能优化
dns是否可以通过缓存减少dns查询时间？
网络请求的过程走最近的网络请求？
相同的静态资源是否可以缓存？
能否减少请求http请求大小？
减少http请求
服务端渲染

资源合并与压缩--减少http请求数量和减少请求资源的大小
google首页案例
1.html压缩 nodejs html-minifier
2.css压缩 clean-css
3.js的压缩和混淆 uglifyjs
4.文件合并 公共库合并，不同页面的合并
5.开启gzip


##### 强缓存和协商缓存
1.cache-control: max-age=xxxx，public
客户端和代理服务器都可以缓存该资源；
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求

2.cache-control: max-age=xxxx，private
只让客户端可以缓存该资源；代理服务器不缓存
客户端在xxx秒内直接读取缓存,statu code:200

3.cache-control: max-age=xxxx，immutable
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

4.cache-control: no-cache
跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

5.cache-control: no-store
不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。
